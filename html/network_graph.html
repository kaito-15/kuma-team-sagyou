<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bear Killed Network // Time Series</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+JP:wght@300;500;700&display=swap');

        body {
            background-color: #050505;
            color: #e0faff;
            font-family: 'Noto Sans JP', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #00f2ff, #ff0055);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 242, 255, 0.5));
        }

        h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: #ccc;
            margin: 5px 0 20px 0;
            letter-spacing: 1px;
        }

        #controls {
            pointer-events: auto;
            background: rgba(10, 10, 15, 0.85);
            padding: 20px;
            border: 1px solid #333;
            border-left: 4px solid #00f2ff;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            width: 250px;
            border-radius: 0 20px 0 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
            font-family: 'Orbitron', sans-serif;
        }

        input[type=range] {
            width: 100%;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ff0055;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px #ff0055;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        button {
            background: transparent;
            border: 1px solid #00f2ff;
            color: #00f2ff;
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            width: 100%;
            letter-spacing: 1px;
        }

        button:hover {
            background: #00f2ff;
            color: #000;
            box-shadow: 0 0 15px #00f2ff;
        }

        #year-display-bg {
            font-family: 'Orbitron', sans-serif;
            font-size: 8rem;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.05);
            position: absolute;
            bottom: 20px;
            right: 40px;
            z-index: 1;
            pointer-events: none;
        }

        #graph-container {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 5;
        }

        .tooltip {
            position: absolute;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid #00f2ff;
            color: #e0faff;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 0.9rem;
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.3);
            display: none;
            z-index: 20;
        }

        /* Legend */
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
            color: #ccc;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            margin-right: 8px;
            border-radius: 50%;
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.2;
        }
    </style>
</head>

<body>
    <div class="scanlines"></div>

    <div id="ui-layer">
        <h1>BEAR NETWORK</h1>
        <h2>Similarity Threshold: 50</h2>

        <div id="controls">
            <div class="control-group">
                <label>TIMELINE <span id="current-year-val"></span></label>
                <input type="range" id="year-slider" min="2000" max="2025" step="1">
            </div>
            <div class="control-group">
                <button id="play-btn">START SIMULATION</button>
            </div>
            <div class="control-group">
                <label>REGIONS</label>
                <div id="legend"></div>
            </div>
        </div>
    </div>

    <div id="year-display-bg">LOADING</div>
    <div id="graph-container"></div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        const CSV_PATH = '../data/bear_killed_count.csv';
        const THRESHOLD = 50;

        // Region Mapping & Colors
        const REGIONS = {
            "北海道": "Hokkaido",
            "青森": "Tohoku", "岩手": "Tohoku", "宮城": "Tohoku", "秋田": "Tohoku", "山形": "Tohoku", "福島": "Tohoku",
            "茨城": "Kanto", "栃木": "Kanto", "群馬": "Kanto", "埼玉": "Kanto", "千葉": "Kanto", "東京": "Kanto", "神奈川": "Kanto",
            "新潟": "Chubu", "富山": "Chubu", "石川": "Chubu", "福井": "Chubu", "山梨": "Chubu", "長野": "Chubu", "岐阜": "Chubu", "静岡": "Chubu", "愛知": "Chubu",
            "三重": "Kansai", "滋賀": "Kansai", "京都": "Kansai", "大阪": "Kansai", "兵庫": "Kansai", "奈良": "Kansai", "和歌山": "Kansai",
            "鳥取": "Chugoku", "島根": "Chugoku", "岡山": "Chugoku", "広島": "Chugoku", "山口": "Chugoku",
            "徳島": "Shikoku", "香川": "Shikoku", "愛媛": "Shikoku", "高知": "Shikoku",
            "福岡": "Kyushu", "佐賀": "Kyushu", "長崎": "Kyushu", "熊本": "Kyushu", "大分": "Kyushu", "宮崎": "Kyushu", "鹿児島": "Kyushu", "沖縄": "Kyushu"
        };

        const REGION_COLORS = {
            "Hokkaido": "#00f2ff", // Cyan
            "Tohoku": "#0099ff",   // Blue
            "Kanto": "#9d00ff",    // Purple
            "Chubu": "#00ff41",    // Green
            "Kansai": "#ff9500",   // Orange
            "Chugoku": "#ffeb3b",  // Yellow
            "Shikoku": "#ff00d4",  // Pink
            "Kyushu": "#ff0055"    // Red
        };

        // State
        let allData = [];
        let currentYear = 2000;
        let isPlaying = false;
        let animationInterval;
        let svg, g, simulation, link, node;
        let width, height;

        async function init() {
            const rawData = await loadData();
            if (!rawData) return;

            allData = processRawData(rawData);
            setupUI();
            setupGraph();
            updateGraph(currentYear);
        }

        function loadData() {
            return new Promise((resolve) => {
                Papa.parse(CSV_PATH, {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    transformHeader: (h) => h.trim(),
                    complete: (results) => resolve(results.data),
                    error: (err) => {
                        console.error('Error loading CSV:', err);
                        resolve(null);
                    }
                });
            });
        }

        function processRawData(rows) {
            // Convert to { year: [ { id, count, region } ] }
            const map = {};
            let minYear = 9999;
            let maxYear = 0;

            rows.forEach(r => {
                const year = parseInt(r.year);
                const pref = r.prefecture;
                // Robust parsing of count column
                const count = parseInt(r.bear_killed_count) || 0;

                if (!year || !pref) return;

                if (year < minYear) minYear = year;
                if (year > maxYear) maxYear = year;

                if (!map[year]) map[year] = [];
                map[year].push({
                    id: pref,
                    count: count,
                    region: REGIONS[pref] || 'Unknown'
                });
            });

            // Set slider range
            const slider = document.getElementById('year-slider');
            slider.min = minYear;
            slider.max = maxYear;
            slider.value = minYear;
            currentYear = minYear;

            return map;
        }

        function setupUI() {
            const legendContainer = document.getElementById('legend');
            Object.keys(REGION_COLORS).forEach(region => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background:${REGION_COLORS[region]}; box-shadow: 0 0 5px ${REGION_COLORS[region]}"></div>${region}`;
                legendContainer.appendChild(item);
            });

            const slider = document.getElementById('year-slider');
            slider.addEventListener('input', (e) => {
                if (isPlaying) stopAnimation();
                currentYear = parseInt(e.target.value);
                updateGraph(currentYear);
            });

            const btn = document.getElementById('play-btn');
            btn.addEventListener('click', toggleAnimation);
        }

        function setupGraph() {
            const container = document.getElementById('graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .call(d3.zoom().on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

            g = svg.append('g');

            // Initialize Layout Forces
            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                // Collide radius will be dynamic
                .force('collide', d3.forceCollide(20).iterations(2))
                .on('tick', ticked);

            link = g.append('g').attr('class', 'links').selectAll('line');
            node = g.append('g').attr('class', 'nodes').selectAll('g');
        }

        function updateGraph(year) {
            document.getElementById('current-year-val').textContent = `// ${year}`;
            document.getElementById('year-display-bg').textContent = year;
            document.getElementById('year-slider').value = year;

            const nodesData = allData[year] || [];

            // Calc Min/Max for current year to normalize Radius
            const maxCount = d3.max(nodesData, d => d.count) || 1;
            const minCount = d3.min(nodesData, d => d.count) || 0;

            // Dynamic Radius Scale
            const rScale = d3.scaleSqrt()
                .domain([0, maxCount]) // 0 to max for correct scaling of "0"
                .range([5, 30]);      // Min radius 5, Max 30

            // Re-calculate links
            const linksData = [];
            for (let i = 0; i < nodesData.length; i++) {
                for (let j = i + 1; j < nodesData.length; j++) {
                    const countA = nodesData[i].count;
                    const countB = nodesData[j].count;
                    const valA = String(countA);
                    const valB = String(countB);

                    const diff = Math.abs(countA - countB);
                    const closeValue = diff <= THRESHOLD;

                    const digitIncluded = (valA.length > 0 && valB.length > 0 && valA !== valB) && (valA.includes(valB) || valB.includes(valA));

                    if (closeValue || digitIncluded) {
                        linksData.push({
                            source: nodesData[i].id,
                            target: nodesData[j].id,
                            diff: diff,
                            type: digitIncluded ? 'inclusion' : 'proximity'
                        });
                    }
                }
            }

            // Persistence
            const oldNodes = new Map(node.data().map(d => [d.id, d]));
            nodesData.forEach(d => {
                const old = oldNodes.get(d.id);
                if (old) {
                    d.x = old.x;
                    d.y = old.y;
                    d.vx = old.vx;
                    d.vy = old.vy;
                } else {
                    d.x = width / 2 + (Math.random() - 0.5) * 50;
                    d.y = height / 2 + (Math.random() - 0.5) * 50;
                }
            });

            // Update force collide based on new radii
            simulation.force('collide', d3.forceCollide(d => rScale(d.count) + 5).iterations(2));

            simulation.nodes(nodesData);
            simulation.force('link').links(linksData);
            simulation.alpha(1).restart();

            // --- LINKS ---
            link = link.data(linksData, d => `${d.source.id}-${d.target.id}`);
            link.exit().remove();

            const linkEnter = link.enter().append('line')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1);

            link = linkEnter.merge(link)
                .transition().duration(500)
                .attr('stroke', d => d.type === 'inclusion' ? '#ff0055' : '#333')
                .attr('stroke-width', d => d.type === 'inclusion' ? 2 : Math.max(0.5, 2 - (d.diff / THRESHOLD) * 2));

            // --- NODES ---
            node = node.data(nodesData, d => d.id);
            node.exit().transition().duration(500).attr('opacity', 0).remove();

            const nodeEnter = node.enter().append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            nodeEnter.append('circle')
                .attr('r', 0)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5)
                .style('cursor', 'pointer');

            nodeEnter.append('text')
                .text(d => `${d.id} ${d.count}`)
                .attr('x', 12)
                .attr('y', 4)
                .attr('fill', '#ccc')
                .style('font-size', '10px')
                .style('pointer-events', 'none')
                .style('text-shadow', '0 0 3px #000')
                .style('opacity', 0);

            nodeEnter.on('mouseover', (event, d) => showTooltip(event, d))
                .on('mouseout', hideTooltip);

            node = nodeEnter.merge(node);

            // Update node attributes
            node.select('circle')
                .transition().duration(500)
                .attr('r', d => rScale(d.count)) // Use dynamic scale
                .attr('fill', d => REGION_COLORS[d.region] || '#999');

            node.select('text')
                .text(d => `${d.id} ${d.count}`)
                .transition().duration(500)
                .style('opacity', 1);

            // Grouping Force
            simulation.force('cluster', alpha => {
                const foci = getRegionFoci();
                for (const d of nodesData) {
                    const focus = foci[d.region];
                    if (focus) {
                        d.vx += (focus.x - d.x) * alpha * 0.05;
                        d.vy += (focus.y - d.y) * alpha * 0.05;
                    }
                }
            });
        }

        const regionKeys = Object.keys(REGION_COLORS);
        const regionFoci = {};
        function getRegionFoci() {
            if (Object.keys(regionFoci).length > 0) return regionFoci;
            const radius = Math.min(width, height) * 0.35;
            const angleStep = (2 * Math.PI) / regionKeys.length;
            regionKeys.forEach((key, i) => {
                const angle = i * angleStep - Math.PI / 2;
                regionFoci[key] = {
                    x: width / 2 + Math.cos(angle) * radius,
                    y: height / 2 + Math.sin(angle) * radius
                };
            });
            return regionFoci;
        }

        function ticked() {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('transform', d => `translate(${d.x},${d.y})`);
        }

        function toggleAnimation() {
            const btn = document.getElementById('play-btn');
            if (isPlaying) {
                stopAnimation();
            } else {
                isPlaying = true;
                btn.textContent = 'STOP SIMULATION';
                const slider = document.getElementById('year-slider');
                let max = parseInt(slider.max);
                animationInterval = setInterval(() => {
                    if (currentYear >= max) {
                        currentYear = parseInt(slider.min);
                    } else {
                        currentYear++;
                    }
                    updateGraph(currentYear);
                }, 1000);
            }
        }

        function stopAnimation() {
            isPlaying = false;
            clearInterval(animationInterval);
            document.getElementById('play-btn').textContent = 'RESUME SIMULATION';
        }

        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        const tooltip = document.getElementById('tooltip');
        function showTooltip(event, d) {
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.innerHTML = `
                <strong>${d.id} (${d.region})</strong><br>
                Count: ${d.count}<br>
                Year: ${currentYear}
            `;
            d3.select(event.currentTarget).select('circle')
                .attr('stroke', '#ffff00')
                .attr('stroke-width', 3);
        }

        function hideTooltip(event) {
            tooltip.style.display = 'none';
            d3.select(event.currentTarget).select('circle')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1.5);
        }

        init();
    </script>
</body>

</html>