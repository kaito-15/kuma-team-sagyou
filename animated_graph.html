<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bear Sightings Bar Chart Race</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        h1 {
            margin-top: 20px;
            font-size: 2rem;
            text-align: center;
        }

        #chart-container {
            position: relative;
            width: 960px;
            height: 600px;
            background: #2a2a2a;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            margin: 20px;
        }

        .bar {
            fill-opacity: 0.8;
        }

        .bar-label {
            font-weight: bold;
            fill: #fff;
            font-size: 14px;
            alignment-baseline: middle;
        }

        .value-label {
            fill: #fff;
            font-size: 14px;
            font-weight: bold;
            alignment-baseline: middle;
            text-anchor: start;
        }

        .year-label {
            font-size: 120px;
            font-weight: bold;
            fill: #444;
            position: absolute;
            bottom: 40px;
            right: 40px;
            pointer-events: none;
            opacity: 0.5;
        }

        .controls {
            margin-bottom: 20px;
        }

        button {
            background-color: #ff4d4d;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #ff3333;
        }

        .axis text {
            fill: #aaa;
            font-size: 12px;
        }

        .axis line,
        .axis path {
            stroke: #444;
        }
    </style>
</head>

<body>

    <h1>都道府県別 クマ出没件数推移 (2009-2023)</h1>

    <div class="controls">
        <button id="replay-btn">Replay Animation</button>
    </div>

    <div id="chart-container"></div>

    <script>
        // Configuration
        const width = 960;
        const height = 600;
        const margin = { top: 30, right: 80, bottom: 30, left: 100 };
        const barSize = 48;
        const n = 12; // Number of bars to show
        const duration = 750; // Animation duration per frame in ms
        const k = 10; // Interpolation frames

        const svg = d3.select("#chart-container")
            .append("svg")
            .attr("viewBox", [0, 0, width, height])
            .attr("width", width)
            .attr("height", height);

        // Color scale
        const color = d3.scaleOrdinal(d3.schemeTableau10);

        // Load Data
        d3.csv("kuma_buna_all_long_intclean_fixed.csv").then(function (data) {
            // Parse data
            // Expected columns: 年度,都道府県,結実,出没件数,...
            // We need to pivot this to: Year -> [{name: Pref, value: Count}, ...]

            const formattedData = [];

            data.forEach(d => {
                const year = +d["年度"];
                const name = d["都道府県"];
                const value = +d["出没件数"];

                if (year && name && !isNaN(value)) {
                    formattedData.push({ year, name, value });
                }
            });

            const names = new Set(formattedData.map(d => d.name));

            // Group by year
            const datevalues = Array.from(d3.rollup(formattedData, ([d]) => d.value, d => d.year, d => d.name))
                .map(([date, data]) => [new Date(date, 0, 1), data])
                .sort(([a], [b]) => d3.ascending(a, b));

            // Generate keyframes
            const keyframes = [];
            let ka, a, kb, b;
            for ([[ka, a], [kb, b]] of d3.pairs(datevalues)) {
                for (let i = 0; i < k; ++i) {
                    const t = i / k;
                    keyframes.push([
                        new Date(ka * (1 - t) + kb * t),
                        rank(name => (a.get(name) || 0) * (1 - t) + (b.get(name) || 0) * t)
                    ]);
                }
            }
            keyframes.push([new Date(kb), rank(name => b.get(name) || 0)]);

            function rank(value) {
                const data = Array.from(names, name => ({ name, value: value(name) }));
                data.sort((a, b) => d3.descending(a.value, b.value));
                for (let i = 0; i < data.length; ++i) data[i].rank = Math.min(n, i);
                return data;
            }

            const nameframes = d3.groups(keyframes.flatMap(([, data]) => data), d => d.name);
            const prev = new Map(nameframes.flatMap(([, data]) => d3.pairs(data, (a, b) => [b, a])));
            const next = new Map(nameframes.flatMap(([, data]) => d3.pairs(data)));

            // Scales
            const x = d3.scaleLinear([0, 1], [margin.left, width - margin.right]);
            const y = d3.scaleBand()
                .domain(d3.range(n + 1))
                .rangeRound([margin.top, margin.top + barSize * (n + 1 + 0.1)])
                .padding(0.1);

            // Drawing
            const yearLabel = svg.append("text")
                .attr("class", "year-label")
                .attr("text-anchor", "end")
                .attr("x", width - 40)
                .attr("y", height - 40)
                .text(datevalues[0][0].getFullYear());

            const xAxis = d3.axisTop(x)
                .ticks(width / 160)
                .tickSizeOuter(0)
                .tickSizeInner(-barSize * (n + y.padding()));

            const gAxis = svg.append("g")
                .attr("transform", `translate(0,${margin.top})`)
                .call(xAxis);

            let bars = svg.append("g").selectAll("rect");
            let labels = svg.append("g").selectAll("text");
            let values = svg.append("g").selectAll("text");

            // Animation Loop
            let frameIndex = 0;
            let interval = null;

            function update(keyframe) {
                const [date, data] = keyframe;

                // Update domain
                x.domain([0, d3.max(data, d => d.value)]);

                // Update axis
                gAxis.transition().duration(duration / k).ease(d3.easeLinear).call(xAxis);

                // Update year
                yearLabel.text(date.getFullYear());

                // Bars
                bars = bars.data(data.slice(0, n), d => d.name)
                    .join(
                        enter => enter.append("rect")
                            .attr("class", "bar")
                            .attr("fill", d => color(d.name))
                            .attr("height", y.bandwidth())
                            .attr("x", x(0))
                            .attr("y", d => y((prev.get(d) || d).rank))
                            .attr("width", d => x((prev.get(d) || d).value) - x(0)),
                        update => update,
                        exit => exit.transition().duration(duration / k).remove()
                            .attr("y", d => y((next.get(d) || d).rank))
                            .attr("width", d => x((next.get(d) || d).value) - x(0))
                    )
                    .call(bar => bar.transition().duration(duration / k).ease(d3.easeLinear)
                        .attr("y", d => y(d.rank))
                        .attr("width", d => x(d.value) - x(0)));

                // Labels (Prefecture Name)
                labels = labels.data(data.slice(0, n), d => d.name)
                    .join(
                        enter => enter.append("text")
                            .attr("class", "bar-label")
                            .attr("transform", d => `translate(${x((prev.get(d) || d).value) - 10},${y((prev.get(d) || d).rank) + y.bandwidth() / 2})`)
                            .attr("text-anchor", "end")
                            .text(d => d.name),
                        update => update,
                        exit => exit.transition().duration(duration / k).remove()
                            .attr("transform", d => `translate(${x((next.get(d) || d).value) - 10},${y((next.get(d) || d).rank) + y.bandwidth() / 2})`)
                    )
                    .call(text => text.transition().duration(duration / k).ease(d3.easeLinear)
                        .attr("transform", d => `translate(${x(d.value) - 10},${y(d.rank) + y.bandwidth() / 2})`)
                        .attr("x", 0) // Reset x to ensure transform works
                    );

                // Values (Count)
                values = values.data(data.slice(0, n), d => d.name)
                    .join(
                        enter => enter.append("text")
                            .attr("class", "value-label")
                            .attr("transform", d => `translate(${x((prev.get(d) || d).value) + 10},${y((prev.get(d) || d).rank) + y.bandwidth() / 2})`)
                            .text(d => Math.round(d.value)),
                        update => update,
                        exit => exit.transition().duration(duration / k).remove()
                            .attr("transform", d => `translate(${x((next.get(d) || d).value) + 10},${y((next.get(d) || d).rank) + y.bandwidth() / 2})`)
                    )
                    .call(text => text.transition().duration(duration / k).ease(d3.easeLinear)
                        .attr("transform", d => `translate(${x(d.value) + 10},${y(d.rank) + y.bandwidth() / 2})`)
                        .tween("text", function (d) {
                            const i = d3.interpolateRound((prev.get(d) || d).value, d.value);
                            return function (t) {
                                this.textContent = i(t);
                            };
                        })
                    );
            }

            function play() {
                if (interval) clearInterval(interval);
                frameIndex = 0;
                interval = setInterval(() => {
                    if (frameIndex >= keyframes.length) {
                        clearInterval(interval);
                        return;
                    }
                    update(keyframes[frameIndex]);
                    frameIndex++;
                }, duration / k);
            }

            // Start animation
            play();

            // Replay button
            d3.select("#replay-btn").on("click", play);

        }).catch(err => {
            console.error("Error loading CSV:", err);
            d3.select("#chart-container").append("p").style("color", "red").text("Error loading data. Check console.");
        });

    </script>
</body>

</html>